"""
Python文件的学习
"""
# -*- coding: utf-8 -*-
#encoding=utf-8

"""
# ********************************  文件用法汇总  ********************************

* 文件只是连续的字节序列

* 文件类型的工厂函数：  open()和file()

        * 这两个函数的功能完全一样,两者都是返回一个文件对象, 利用 encoding = "utf-8"来指示编码，默认用的ansi

        * 语法：    open(file_name [, access_mode][, buffering]，[,encoding])

        * 参数：    file_nam--file_name变量是一个包含了你要访问的文件名称的字符串值   

                    access_mode--access_mode决定了打开文件的模式：只读，写入，追加等。
                                这个参数是非强制的，默认文件访问模式为只读(r)

                    buffering-- 如果buffering的值被设为0，就不会有寄存。
                                如果buffering的值取1，访问文件时会寄存行。
                                如果将buffering的值设为大于1的整数，表明了这就是的寄存区的缓冲大小。
                                如果取负值，寄存区的缓冲大小则为系统默认。

                    encoding-- 指定编码方式，默认为ansi

        * access_mode:

                    r	        以只读方式打开文件。文件的指针将会放在文件的开头, 这是默认模式
                    rb	        以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头
                    r+	        打开一个文件用于读写。文件指针将会放在文件的开头
                    rb+	        以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头
                    w	        打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件
                    wb	        以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件
                    w+	        打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件
                    wb+	        以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件
                    a	        打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。
                                也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入
                    ab	        以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。
                                也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入
                    a+	        打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。
                                文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写
                    ab+	        以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。
                                如果该文件不存在，创建新文件用于读写

* 文件类型的内建方法

    * 读取：

            .read([size]):  从当前指针处开始读取字节, 默认情况下读到文件尾，也可用size参数指定最大读取大小, 返回读取文本的字符串

            .readline([size]): 从当前指针读取直到下一个行结束符，也可用size参数指定最大读取大小, 返回读取文本的字符串

            .readlines(): 从当前指针读取直至文件尾，返回一个字符串列表，每项字符串都是所读取的一行

    * 写入：

            .write(str): 把含有文本数据或二进制数据块的字符串写入到文件中去，无返回值

            .writelines(str_seq): 接收字符串列表将其写入文件。注意，行结束符并不会被自动加入,
                                    所以如果需要的话，必须在调用writelines()前给每行结尾加上行结束符

            * 特别注意： 

                    * 读取和写入字符串时用的都用的是open中指定的编码格式

                    * 如果是以二进制方式打开的文件,则读取和写入都是二进制类型的,而不是字符串或字符串列表  

    * 文件内指针的移动：

            .seek(offset [,from]): 移动文件内指针到某一位置，from是指偏移量的参考位置，
                                    0(默认)代表从文件首算起，1代表从当前位置算起，2代表从文件尾算起;
                                    offset是指的偏移量, 正表示往文件尾方向，负表示往文件头方向

            .tell(): 返回当前文件内指针的位置，从文件首算起，单位为字节

    * 其它方法：

            .close(): 关闭所属文件对象的文件，关闭后文件不能再进行读写操作

            .fileno(): 返回打开文件的描述符，用于一些底层操作

            .flush(): 直接把内部缓冲区中的数据立刻写入文件，而不是被动地等待输出缓冲区被写入(刷新缓存区)

            .truncate([size]): 从文件的首行首字符开始截断，截断文件为 size 个字符，无 size 表示从当前位置截断，
                                截断之后，后面的所有字符被删除

            .isatty(): 文件是否是一个终端设备文件

* 文件内建属性

            .closed: 判断文件是否关闭

            .encoding: 文件编码方式

            .mode:  文件对象的访问模式

            .name: 文件名

            .newlines: 未读到行分隔符时为None, 只有一种行分隔符时返时一个字符串，有多种时是所有行分隔符的字符串列表

* 文件迭代: 

        * file是一个可迭代类型，迭代方式是依次读取每行得到的字符串赋值给迭代变量 

        * 文件迭代格式： for eachline in file_obj

        * 文件既是一个可迭代对象，又是一个迭代器，所以可以使用next()内建函数

"""


f = open('Abstract.txt','r+', encoding="utf-8")
print("read()方法： "+f.read())

print('')
f.seek(0)
print("readline()方法： "+f.readline())

print('')
f.seek(0)
print("readlines()方法： ", f.readlines())

print("")
print("write()方法： " )
f.write(u"\n\n 测试write()方法 \n")

print("writelines()方法： " )
f.writelines(['writelines()方法测试1',' writelines()方法测试2'])

print("tell()方法：", f.tell())

#print("truncate()方法:")
#f.truncate(780)

# 文件对象是一个迭代器，具有__next__()方法
f.seek(0)
print(next(f))
print(next(f))

# 文件属性
print("closed属性：", f.closed)
print("encoding属性：", f.encoding)
print("mode属性：", f.mode)
print("name属性：", f.name)
print("newlines属性:",repr(f.newlines))

f.close()
