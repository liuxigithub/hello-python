"""
模块的相关内容笔记
"""

"""
# *********************  函数的相关知识 ************************

* 在Python中，一个.py文件就称之为一个模块(Module),即一个文件被看作一个独立的模块，一个模块也可以被看做是一个文件

* 如果说模块是按照逻辑来组织Python代码的方法，那么文件就是物理层上组织模块的方法

* 命名空间就是一个从名称到对象的关系映射集合

* 每个模块都定义了它自己唯一的命名空间

* 命名空间与作用域的比较：

        * 命名空间是纯粹意义上的名字和对象间的映射关系，而作用域还指出了从用户代码的哪些物理位置可以访问到这些名字

        * 命名空间-->"它存在吗"；变量作用域-->"我能看见它吗"

* 添加模块搜索路径：

    * PATHONPATH环境变量

    * sys模块的sys.path属性，如

            import sys
            sys.path.append('/home/lib')
            import my_module

* import语句：Python允许导入其它模块以实现代码重用

        格式：  import module1[, module2[,... moduleN]  # 只导入模块
                import module as md        # 只导入模块,且为它取一个别名
                from module import nam1 [,name2,...] # 只导入模块中的名字
                from module import nam1 as nm1  # 只导入模块中的名字,且为它取一个别名
                from module import * # 导入模块中的所有名字

        * 在导入模块时只能使用模块名，而不是使用带.py后缀的模块文件名

        * 可以用as关键字为模块起一个别名

        * 建议导入顺序：标准库模块-->Python第三方库-->应用程序自定义模块

* 模块除了方法定义，还可以包括可执行的代码(顶层代码),这些代码一般用来初始化这个模块。这些代码只有在第一次被导入时才会被执行

* 一个模块只被加载一次，无论它被导入多少次，而且加载只在第一次导入时发生

* 模块是可以导入其他模块的

* 利用dir()可以查看模块内的属性和函数

* [域作用原则]被导入的模块中的变量遵循域作用原则，如果在一个模块的顶层导入，那么这的作用域是全局的，如果在函数中导入，则是局域的

* 当只导入模块的名字时，如果全局作用域中已存在这个名字，那么模块中的这个变量的值并不能在全局作用域中被更改，只能被引用

* __name__属性:

    * 每个模块都有一个__name__属性，当模块自身在运行时，其值是'__main__', 当模块是被导入时，它的值是模块的名字

*  包： 
        * 包是一个有层次的文件目录结构，它定义了一个由模块和子包组成的Python应用程序执行环境

        * 包为平坦的名称空间加入了有层次的组织结构

        * 基于包，Python在执行模块导入时可以指定模块的导入路径 import pack1.pack2.mod1

"""
#%% 
from imptee import foo, show
print(foo)
show()
foo = 123
print('foo from impter:',foo)
show()
print(__name__)

#%%
import imptee
imptee.show()
imptee.foo = 124
print('foo from impter:',foo)
show()